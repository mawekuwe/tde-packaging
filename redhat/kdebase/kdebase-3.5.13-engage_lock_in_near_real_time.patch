commit 8d521d0b6ba88c6e679e7453f02897c8db7bbdf5
Author: Timothy Pearson <kb9vqf@pearsoncomputing.net>
Date:   1328671935 -0600

    Update lock process to engage the lock in near real time

diff --git a/kdesktop/lock/CMakeLists.txt b/kdesktop/lock/CMakeLists.txt
index 5530d4c..7a35121 100644
--- a/kdesktop/lock/CMakeLists.txt
+++ b/kdesktop/lock/CMakeLists.txt
@@ -35,6 +35,6 @@ set( ${target}_SRCS
 
 tde_add_executable( ${target} AUTOMOC
   SOURCES ${${target}_SRCS}
-  LINK kdesktopsettings-static dmctl-static kio-shared Xext ${GL_LIBRARY}
+  LINK kdesktopsettings-static dmctl-static kio-shared Xext ${GL_LIBRARY} "-z\ now"
   DESTINATION ${BIN_INSTALL_DIR}
 )
diff --git a/kdesktop/lock/main.cc b/kdesktop/lock/main.cc
index 0cbef60..132ff30 100644
--- a/kdesktop/lock/main.cc
+++ b/kdesktop/lock/main.cc
@@ -1,6 +1,7 @@
 /* This file is part of the KDE project
    Copyright (C) 1999 David Faure
    Copyright (c) 2003 Oswald Buddenhagen <ossi@kde.org>
+   Copyright (c) 2010-2012 Timothy Pearson <kb9vqf@pearsoncomputing.net>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
@@ -43,6 +44,13 @@ bool trinity_desktop_lock_use_sak = FALSE;
 
 bool trinity_desktop_lock_forced = FALSE;
 
+bool signalled_forcelock;
+bool signalled_dontlock;
+bool signalled_securedialog;
+bool signalled_blank;
+bool signalled_run;
+bool in_internal_mode = FALSE;
+
 bool MyApp::x11EventFilter( XEvent *ev )
 {
     if (ev->type == XKeyPress || ev->type == ButtonPress) {
diff --git a/kdesktop/lockeng.cc b/kdesktop/lockeng.cc
index 5307c5c..79d27db 100644
--- a/kdesktop/lockeng.cc
+++ b/kdesktop/lockeng.cc
@@ -1,8 +1,9 @@
 //===========================================================================
 //
-// This file is part of the KDE project
+// This file is part of the TDE project
 //
 // Copyright (c) 1999 Martin R. Jones <mjones@kde.org>
+// Copyright (c) 2012 Timothy Pearson <kb9vqf@pearsoncomputing.net>
 //
 
 
@@ -29,6 +30,14 @@ extern xautolock_corner_t xautolock_corners[ 4 ];
 
 bool trinity_lockeng_sak_available = TRUE;
 
+SaverEngine* m_masterSaverEngine = NULL;
+static void sigusr1_handler(int)
+{
+    if (m_masterSaverEngine) {
+        m_masterSaverEngine->lockProcessWaiting();
+    }
+}
+
 //===========================================================================
 //
 // Screen saver engine. Doesn't handle the actual screensaver window,
@@ -42,6 +51,16 @@ SaverEngine::SaverEngine()
       mSAKProcess(NULL),
       mTerminationRequested(false)
 {
+    struct sigaction act;
+
+    // handle SIGUSR1
+    m_masterSaverEngine = this;
+    act.sa_handler= sigusr1_handler;
+    sigemptyset(&(act.sa_mask));
+    sigaddset(&(act.sa_mask), SIGUSR1);
+    act.sa_flags = 0;
+    sigaction(SIGUSR1, &act, 0L);
+
     // Save X screensaver parameters
     XGetScreenSaver(qt_xdisplay(), &mXTimeout, &mXInterval,
                     &mXBlanking, &mXExposures);
@@ -60,6 +79,19 @@ SaverEngine::SaverEngine()
     TQTimer::singleShot( 0, this, TQT_SLOT(handleSecureDialog()) );
 
     configure();
+
+    mLockProcess.clearArguments();
+    TQString path = KStandardDirs::findExe( "kdesktop_lock" );
+    if( path.isEmpty())
+    {
+	kdDebug( 1204 ) << "Can't find kdesktop_lock!" << endl;
+    }
+    mLockProcess << path;
+    mLockProcess << TQString( "--internal" ) << TQString( "%1" ).arg(getpid());
+    if (mLockProcess.start() == false )
+    {
+	kdDebug( 1204 ) << "Failed to start kdesktop_lock!" << endl;
+    }
 }
 
 //---------------------------------------------------------------------------
@@ -68,6 +100,10 @@ SaverEngine::SaverEngine()
 //
 SaverEngine::~SaverEngine()
 {
+    if (mState == Waiting) {
+        kill(mLockProcess.pid(), SIGKILL);
+    }
+
     mLockProcess.detach(); // don't kill it if we crash
     delete mXAutoLock;
 
@@ -86,9 +122,9 @@ void SaverEngine::lock()
     {
         mSAKProcess->kill(SIGTERM);
         ok = startLockProcess( ForceLock );
-// It takes a while for kdesktop_lock to start and lock the screen.
-// Therefore delay the DCOP call until it tells kdesktop that the locking is in effect.
-// This is done only for --forcelock .
+        // It takes a while for kdesktop_lock to start and lock the screen.
+        // Therefore delay the DCOP call until it tells kdesktop that the locking is in effect.
+        // This is done only for --forcelock .
         if( ok && mState != Saving )
         {
             DCOPClientTransaction* trans = kapp->dcopClient()->beginTransaction();
@@ -283,40 +319,42 @@ bool SaverEngine::startLockProcess( LockType lock_type )
     kdDebug(1204) << "SaverEngine: starting saver" << endl;
     emitDCOPSignal("KDE_start_screensaver()", TQByteArray());
 
-    if (mLockProcess.isRunning())
-    {
-        stopLockProcess();
-    }
-    mLockProcess.clearArguments();
-    TQString path = KStandardDirs::findExe( "kdesktop_lock" );
-    if( path.isEmpty())
-    {
-	kdDebug( 1204 ) << "Can't find kdesktop_lock!" << endl;
-	return false;
+    if (!mLockProcess.isRunning()) {
+	mLockProcess.clearArguments();
+	TQString path = KStandardDirs::findExe( "kdesktop_lock" );
+	if( path.isEmpty())
+	{
+	    kdDebug( 1204 ) << "Can't find kdesktop_lock!" << endl;
+	    return false;
+	}
+	mLockProcess << path;
+	mLockProcess << TQString( "--internal" ) << TQString( "%1" ).arg(getpid());
+        if (mLockProcess.start() == false )
+	{
+	    kdDebug( 1204 ) << "Failed to start kdesktop_lock!" << endl;
+	    return false;
+	}
     }
-    mLockProcess << path;
+
     switch( lock_type )
     {
 	case ForceLock:
-    	    mLockProcess << TQString( "--forcelock" );
+    	    mLockProcess.kill(SIGUSR1);		// Request forcelock
 	  break;
 	case DontLock:
-	    mLockProcess << TQString( "--dontlock" );
+    	    mLockProcess.kill(SIGUSR2);		// Request dontlock
 	  break;
 	case SecureDialog:
-	    mLockProcess << TQString( "--securedialog" );
+    	    mLockProcess.kill(SIGWINCH);	// Request secure dialog
 	  break;
 	default:
 	  break;
     }
-    if (mBlankOnly)
-	    mLockProcess << TQString( "--blank" );
-
-    if (mLockProcess.start() == false )
-    {
-	kdDebug( 1204 ) << "Failed to start kdesktop_lock!" << endl;
-	return false;
+    if (mBlankOnly) {
+	    mLockProcess.kill(SIGTTIN);		// Request blanking
     }
+
+    mLockProcess.kill(SIGTTOU);			// Start lock
     XSetScreenSaver(qt_xdisplay(), 0, mXInterval,  PreferBlanking, mXExposures);
 
     mState = Preparing;
@@ -359,9 +397,7 @@ void SaverEngine::stopLockProcess()
 
 void SaverEngine::lockProcessExited()
 {
-printf("Lock process exited\n\r"); fflush(stdout);
     bool abnormalExit = false;
-    kdDebug(1204) << "SaverEngine: lock exited" << endl;
     if (mLockProcess.normalExit() == false) {
         abnormalExit = true;
     }
@@ -387,6 +423,28 @@ printf("Lock process exited\n\r"); fflush(stdout);
             system("logout");
         }
     }
+    else {
+        // Restart the lock process
+        if (!mLockProcess.isRunning()) {
+            mLockProcess.clearArguments();
+            TQString path = KStandardDirs::findExe( "kdesktop_lock" );
+            if( path.isEmpty())
+            {
+                kdDebug( 1204 ) << "Can't find kdesktop_lock!" << endl;
+            }
+            mLockProcess << path;
+            mLockProcess << TQString( "--internal" ) << TQString( "%1" ).arg(getpid());
+            if (mLockProcess.start() == false )
+            {
+                kdDebug( 1204 ) << "Failed to start kdesktop_lock!" << endl;
+            }
+        }
+    }
+}
+
+void SaverEngine::lockProcessWaiting()
+{
+    kdDebug(1204) << "SaverEngine: lock exited" << endl;
     if (trinity_lockeng_sak_available == TRUE) {
         handleSecureDialog();
     }
diff --git a/kdesktop/lockeng.h b/kdesktop/lockeng.h
index ae81f90..ae08e9a 100644
--- a/kdesktop/lockeng.h
+++ b/kdesktop/lockeng.h
@@ -78,6 +78,9 @@ public:
      */
     virtual void saverLockReady();
 
+public slots:
+    void lockProcessWaiting();
+
 protected slots:
     void idleTimeout();
     void lockProcessExited();
