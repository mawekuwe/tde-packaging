commit 57f5c0698d49f0a0a7a55c75404f5b9ded910002
Author: Timothy Pearson <kb9vqf@pearsoncomputing.net>
Date:   1348355175 -0500

    Lower override redirect windows instead of unmapping them on lock start
    Restore lowered windows on lock exit
    This provides a better solution to Bug 1079

diff --git a/kdesktop/lock/lockprocess.cc b/kdesktop/lock/lockprocess.cc
index 5265bc6..7191346 100644
--- a/kdesktop/lock/lockprocess.cc
+++ b/kdesktop/lock/lockprocess.cc
@@ -138,6 +138,8 @@ extern bool trinity_desktop_lock_delay_screensaver_start;
 extern bool trinity_desktop_lock_use_sak;
 extern bool trinity_desktop_lock_forced;
 
+extern TQXLibWindowList trinity_desktop_lock_hidden_window_list;
+
 bool trinity_desktop_lock_autohide_lockdlg = TRUE;
 bool trinity_desktop_lock_closing_windows = FALSE;
 bool trinity_desktop_lock_in_sec_dlg = FALSE;
@@ -961,7 +963,7 @@ void LockProcess::createSaverWindow()
     setGeometry(0, 0, mRootWidth, mRootHeight);
 
     // HACK
-    // Close all tooltips and notification windows
+    // Hide all tooltips and notification windows
     {
         Window rootWindow = RootWindow(x11Display(), x11Screen());
         Window parent;
@@ -974,7 +976,10 @@ void LockProcess::createSaverWindow()
             for (unsigned int i=0; i<noOfChildren; i++) {
                 if (XGetWindowAttributes(x11Display(), children[i], &childAttr) && XGetTransientForHint(x11Display(), children[i], &childTransient)) {
                     if ((childAttr.map_state == IsViewable) && (childAttr.override_redirect) && (childTransient)) {
-                        XUnmapWindow(x11Display(), children[i]);
+                        if (!trinity_desktop_lock_hidden_window_list.contains(children[i])) {
+                            trinity_desktop_lock_hidden_window_list.append(children[i]);
+                        }
+                        XLowerWindow(x11Display(), children[i]);
                     }
                 }
             }
diff --git a/kdesktop/lock/lockprocess.h b/kdesktop/lock/lockprocess.h
index 0dacc46..7fd4236 100644
--- a/kdesktop/lock/lockprocess.h
+++ b/kdesktop/lock/lockprocess.h
@@ -38,6 +38,8 @@ struct GreeterPluginHandle {
 #define FIFO_FILE_OUT "/tmp/ksocket-global/kdesktoplockcontrol_out"
 #define PIPE_CHECK_INTERVAL 50
 
+typedef TQValueList<Window> TQXLibWindowList;
+
 //===========================================================================
 //
 // Screen saver handling process.  Handles screensaver window,
diff --git a/kdesktop/lock/main.cc b/kdesktop/lock/main.cc
index e74d9f9..a95747e 100644
--- a/kdesktop/lock/main.cc
+++ b/kdesktop/lock/main.cc
@@ -47,6 +47,8 @@ else {													\
 }													\
 tdmconfig->setGroup("X-*-Greeter");
 
+TQXLibWindowList trinity_desktop_lock_hidden_window_list;
+
 // [FIXME] Add GUI configuration checkboxes for these three settings (see kdesktoprc [ScreenSaver] UseUnmanagedLockWindows, DelaySaverStart, and UseTDESAK)
 bool trinity_desktop_lock_use_system_modal_dialogs = FALSE;
 bool trinity_desktop_lock_delay_screensaver_start = FALSE;
@@ -78,16 +80,43 @@ bool MyApp::x11EventFilter( XEvent *ev )
     }
     else if (ev->type == MapNotify) {
         // HACK
-        // Close all tooltips and notification windows
+        // Hide all tooltips and notification windows
         XMapEvent map_event = ev->xmap;
         XWindowAttributes childAttr;
         Window childTransient;
         if (XGetWindowAttributes(map_event.display, map_event.window, &childAttr) && XGetTransientForHint(map_event.display, map_event.window, &childTransient)) {
             if((childAttr.map_state == IsViewable) && (childAttr.override_redirect) && (childTransient)) {
-                XUnmapWindow(map_event.display, map_event.window);
+                if (!trinity_desktop_lock_hidden_window_list.contains(map_event.window)) {
+                    trinity_desktop_lock_hidden_window_list.append(map_event.window);
+                }
+                XLowerWindow(map_event.display, map_event.window);
             }
         }
     }
+    else if (ev->type == VisibilityNotify) {
+        // HACK
+        // Hide all tooltips and notification windows
+        XVisibilityEvent visibility_event = ev->xvisibility;
+        XWindowAttributes childAttr;
+        Window childTransient;
+        if ((visibility_event.state == VisibilityUnobscured) || (visibility_event.state == VisibilityPartiallyObscured)) {
+            if (XGetWindowAttributes(visibility_event.display, visibility_event.window, &childAttr) && XGetTransientForHint(visibility_event.display, visibility_event.window, &childTransient)) {
+                if((childAttr.map_state == IsViewable) && (childAttr.override_redirect) && (childTransient)) {
+                    if (!trinity_desktop_lock_hidden_window_list.contains(visibility_event.window)) {
+                        trinity_desktop_lock_hidden_window_list.append(visibility_event.window);
+                    }
+                    XLowerWindow(visibility_event.display, visibility_event.window);
+                }
+            }
+        }
+    }
+    else if (ev->type == DestroyNotify) {
+        XDestroyWindowEvent destroy_event = ev->xdestroywindow;
+        if (trinity_desktop_lock_hidden_window_list.contains(destroy_event.window)) {
+            trinity_desktop_lock_hidden_window_list.remove(destroy_event.window);
+        }
+    }
+#if 0
     else if (ev->type == CreateNotify) {
         // HACK
         // Close all tooltips and notification windows
@@ -100,6 +129,7 @@ bool MyApp::x11EventFilter( XEvent *ev )
             }
         }
     }
+#endif
     return KApplication::x11EventFilter( ev );
 }
 
@@ -114,6 +144,14 @@ static KCmdLineOptions options[] =
    KCmdLineLastOption
 };
 
+void restore_hidden_override_redirect_windows() {
+    TQXLibWindowList::iterator it;
+    for (it = trinity_desktop_lock_hidden_window_list.begin(); it != trinity_desktop_lock_hidden_window_list.end(); ++it) {
+        Window win = *it;
+        XRaiseWindow(qt_xdisplay(), win);
+    }
+}
+
 static void sigusr1_handler(int)
 {
     signalled_forcelock = TRUE;
@@ -356,7 +394,10 @@ int main( int argc, char **argv )
         }
 
         if (in_internal_mode == FALSE) {
-            return app.exec();
+            trinity_desktop_lock_hidden_window_list.clear();
+            int ret = app.exec();
+            restore_hidden_override_redirect_windows();
+            return ret;
         }
         else {
             pid_t kdesktop_pid = atoi(args->getOption( "internal" ));
@@ -364,7 +405,9 @@ int main( int argc, char **argv )
                 // The controlling kdesktop process probably died.  Commit suicide...
                 return 12;
             }
+            trinity_desktop_lock_hidden_window_list.clear();
             app.exec();
+            restore_hidden_override_redirect_windows();
             if (kill(kdesktop_pid, SIGUSR1) < 0) {
                 // The controlling kdesktop process probably died.  Commit suicide...
                 return 12;
