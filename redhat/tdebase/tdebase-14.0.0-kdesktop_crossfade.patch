diff -p -up kdebase-3.5.9/kcontrol/background/crossfade.h.crossfade-efect kdebase-3.5.9/kcontrol/background/crossfade.h
--- kdebase-3.5.9/kcontrol/background/crossfade.h.crossfade-efect	2008-03-11 09:17:29.000000000 -0300
+++ kdebase-3.5.9/kcontrol/background/crossfade.h	2008-03-11 09:17:29.000000000 -0300
@@ -0,0 +1,56 @@
+/* vi: ts=8 sts=4 sw=4
+ * kate: space-indent on; tab-width 8; indent-width 4; indent-mode cstyle;
+ *
+ * This file is part of the KDE project, module kdesktop.
+ * Copyright (C) 1999,2000 Geert Jansen <jansen@kde.org>
+ *
+ * You can Freely distribute this program under the GNU General Public
+ * License. See the file "COPYING" for the exact licensing terms.
+ */
+
+#ifndef __crossfade_h_Included__
+#define __crossfade_h_Included__
+
+#include <tqtimer.h>
+#include <tqpainter.h>
+#include <tqpixmap.h>
+#include <X11/X.h>
+#include <X11/Xlib.h>
+#include <X11/Xatom.h>
+#include <X11/extensions/Xrender.h>
+#include <kdebug.h>
+#include <unistd.h>
+
+
+
+inline TQPixmap crossFade(const TQPixmap &pix1, const TQPixmap &pix2, double r_alpha,
+	                bool sync = false){
+
+    TQPixmap pix = TQPixmap(1,1,8); 
+    int mw,mh;
+    mw = pix1.width();
+    mh = pix1.height();
+
+    int alpha = 0xffff * (1-r_alpha);
+    
+    XRenderColor clr = { 0, 0, 0, alpha }; 
+    XRenderPictureAttributes pa;
+    pa.repeat = True;
+    Picture pic = XRenderCreatePicture(pix.x11Display(), pix.handle(),
+	    XRenderFindStandardFormat (pix.x11Display(), PictStandardA8),
+	    CPRepeat, &pa);
+    XRenderFillRectangle(pix.x11Display(), PictOpSrc, pic,
+			 &clr, 0, 0, 1, 1);
+    TQPixmap dst(pix1);
+    dst.detach();
+    XRenderComposite(pix.x11Display(), PictOpOver, pix2.x11RenderHandle(),
+	    pic, dst.x11RenderHandle(),0,0, 0,0, 0,0, mw,mh);
+
+    if (sync) {
+       XSync(pix.x11Display(), false);	
+    }
+    XRenderFreePicture(pix.x11Display(), pic);
+    return dst;
+}
+
+#endif // __crossfade_h_Included__
--- ./kcontrol/background/CMakeLists.txt.ORI	2013-05-08 18:36:33.605165935 +0200
+++ ./kcontrol/background/CMakeLists.txt	2013-05-08 18:37:55.448537081 +0200
@@ -28,7 +28,7 @@
   ##### bgnd (static) #############################
 
   tde_add_library( bgnd STATIC_PIC AUTOMOC
-    SOURCES bgrender.cpp bgsettings.cpp
+    SOURCES bgrender.cpp bgsettings.cpp KCrossBGRender.cc
     LINK ${LIBART_LIBRARIES}
   )
 
--- ./kcontrol/background/bgrender.cpp.ORI	2013-05-08 18:39:20.212849124 +0200
+++ ./kcontrol/background/bgrender.cpp	2013-05-08 18:44:04.200187009 +0200
@@ -10,6 +10,8 @@
 
 #include <config.h>
 
+#include "KCrossBGRender.h"
+
 #include <time.h>
 #include <stdlib.h>
 #include <utime.h>
@@ -1061,7 +1063,7 @@
 }
 
 
-KBackgroundRenderer * KVirtualBGRenderer::renderer(unsigned screen)
+KCrossBGRender * KVirtualBGRenderer::renderer(unsigned screen)
 {
     return m_renderer[screen];
 }
@@ -1220,7 +1222,8 @@
     for (unsigned i=0; i<m_numRenderers; ++i)
     {
         int eScreen = m_bCommonScreen ? 0 : i;
-        KBackgroundRenderer * r = new KBackgroundRenderer( m_desk, eScreen, m_bDrawBackgroundPerScreen, m_pConfig );
+        //KBackgroundRenderer * r = new KBackgroundRenderer( m_desk, eScreen, m_bDrawBackgroundPerScreen, m_pConfig );
+        KCrossBGRender *r = new KCrossBGRender(m_desk, eScreen, m_bDrawBackgroundPerScreen, m_pConfig);
         m_renderer.insert( i, r );
         r->setSize(renderSize(i));
         connect( r, TQT_SIGNAL(imageDone(int,int)), this, TQT_SLOT(screenDone(int,int)) );
@@ -1250,7 +1253,8 @@
     Q_UNUSED(_desk);
     Q_UNUSED(_screen);
 
-    const KBackgroundRenderer * sender = dynamic_cast<const KBackgroundRenderer*>(this->sender());
+    //const KBackgroundRenderer * sender = dynamic_cast<const KBackgroundRenderer*>(this->sender());
+    const KCrossBGRender * sender = dynamic_cast<const KCrossBGRender*>(this->sender());
     int screen = m_renderer.find(sender);
     if (screen == -1)
         //??
--- kdebase-3.5.9/kcontrol/background/KCrossBGRender.h.crossfade-efect	2008-03-11 09:17:29.000000000 -0300
+++ kdebase-3.5.9/kcontrol/background/KCrossBGRender.h	2008-03-11 10:50:24.000000000 -0300
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2008 Danilo Cesar Lemes de Paula <danilo@mandriva.com>
+ * Copyright (C) 2008 Gustavo Boiko <boiko@mandriva.com>
+ * Mandriva Conectiva
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License version 2 as published by the Free Software Foundation.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __KCrossBGRender_h_Included__
+#define __KCrossBGRender_h_Included__
+
+
+#include <tqvaluelist.h>
+#include <tqpixmap.h>
+#include <tqvaluelist.h>
+#include <tqdatetime.h>
+
+#include "bgrender.h"
+
+class TQDomElement;
+
+typedef struct crossEvent{
+	bool transition;
+	TQString pix1;
+	TQString pix2;
+	TQTime stime; //start time
+	TQTime etime; //end time
+} KBGCrossEvent;
+
+
+class KCrossBGRender: public KBackgroundRenderer{
+	
+TQ_OBJECT
+
+public:
+	KCrossBGRender(int desk, int screen, bool drawBackgroundPerScreen, TDEConfig *config=0);
+	~KCrossBGRender();
+
+	bool needWallpaperChange();
+	void changeWallpaper(bool init=false);
+	TQPixmap pixmap();
+	bool usingCrossXml(){return useCrossEfect;};
+
+
+private:
+	TQPixmap pix;
+	int secs;
+	TQString xmlFileName;
+	bool useCrossEfect;
+	
+	int actualPhase;
+	 
+	void createStartTime(TQDomElement e);
+	void createTransition(TQDomElement e);
+	void createStatic(TQDomElement e);
+	bool setCurrentEvent(bool init = false);
+	void initCrossFade(TQString xml);
+	void fixEnabled();
+	TQPixmap getCurrentPixmap();
+	KBGCrossEvent current;
+	TQValueList<KBGCrossEvent> timeList;
+};
+
+#endif // __KCrossBGRender_h_Included__ 
--- ./kcontrol/background/bgrender.h.ORI	2013-05-08 18:46:41.122053931 +0200
+++ ./kcontrol/background/bgrender.h	2013-05-08 18:49:07.510128486 +0200
@@ -28,6 +28,7 @@
 class KTempFile;
 class KShellProcess;
 class TDEStandardDirs;
+class KCrossBGRender;
 
 /**
  * This class renders a desktop background to a TQImage. The operation is
@@ -127,7 +128,7 @@
     KVirtualBGRenderer(int desk, TDEConfig *config=0l);
     ~KVirtualBGRenderer();
     
-    KBackgroundRenderer * renderer(unsigned screen);
+    KCrossBGRender * renderer(unsigned screen);
     unsigned numRenderers() const { return m_numRenderers; }
 
     TQPixmap pixmap();
@@ -173,7 +174,8 @@
     TQSize m_size;
     
     TQMemArray<bool> m_bFinished;
-    TQPtrVector<KBackgroundRenderer> m_renderer;
+    //TQPtrVector<KBackgroundRenderer> m_renderer;
+    TQPtrVector<KCrossBGRender> m_renderer;
     TQPixmap *m_pPixmap;
 };
 
diff -p -up kdebase-3.5.9/kcontrol/background/KCrossBGRender.cc.crossfade-efect kdebase-3.5.9/kcontrol/background/KCrossBGRender.cc
--- kdebase-3.5.9/kcontrol/background/KCrossBGRender.cc.crossfade-efect	2008-03-11 09:17:29.000000000 -0300
+++ kdebase-3.5.9/kcontrol/background/KCrossBGRender.cc	2008-03-11 10:54:41.000000000 -0300
@@ -0,0 +1,362 @@
+/*
+ * Copyright (C) 2008 Danilo Cesar Lemes de Paula <danilo@mandriva.com>
+ * Copyright (C) 2008 Gustavo Boiko <boiko@mandriva.com>
+ * Mandriva Conectiva
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License version 2 as published by the Free Software Foundation.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <tqdom.h>
+#include <tqfile.h>
+
+#include <kdebug.h>
+
+#include "KCrossBGRender.h"
+//#include "crossfade.h"
+#include <tqapplication.h>
+#include <kimageeffect.h>
+
+
+KCrossBGRender::KCrossBGRender(int desk, int screen, bool drawBackgroundPerScreen, TDEConfig *config): KBackgroundRenderer(desk,screen,drawBackgroundPerScreen,config)
+{
+	useCrossEfect = false;
+	if ( wallpaperList()[0].endsWith("xml",false) ) {
+		initCrossFade(wallpaperList()[0]);
+	}
+}
+		
+
+void KCrossBGRender::initCrossFade(TQString xmlFile)
+{	
+	useCrossEfect = true;
+	if (xmlFile.isEmpty()){
+		useCrossEfect = false;
+		return;
+	}
+	secs = 0;
+	timeList.empty();
+
+	// read the XMLfile
+	TQDomDocument xmldoc = TQDomDocument(xmlFile);
+	TQFile file( xmlFile );
+	if ( !file.open( IO_ReadOnly ) ) {
+		useCrossEfect = false;
+		return;
+	}
+	if ( !xmldoc.setContent( &file ) ) {
+		useCrossEfect = false;
+		file.close();
+		return;
+	}
+	file.close();
+
+	TQDomElement docElem = xmldoc.documentElement();
+	TQDomNode n = docElem.firstChild();
+	while( !n.isNull() ) {
+		TQDomElement e = n.toElement(); // try to convert the node to an element.
+		if( !e.isNull() ) {
+			if (e.tagName() == "starttime") {
+				createStartTime(e);	
+			} else if (e.tagName() == "transition") {
+				createTransition(e);
+			} else if (e.tagName() == "static") {
+				createStatic(e);
+			}
+		}
+		n = n.nextSibling();
+	}
+
+	// Setting "now" state
+	setCurrentEvent(true);
+	pix = getCurrentPixmap();
+	
+	useCrossEfect = true;
+}
+
+
+KCrossBGRender::~KCrossBGRender(){
+}
+
+TQPixmap KCrossBGRender::pixmap() {
+	fixEnabled();	
+	if (!useCrossEfect){
+		TQPixmap p = KBackgroundRenderer::pixmap();
+		kdDebug() << "Inherited " << p.size() << endl;
+		if (p.width() == 0 && p.height() == 0){
+			p.convertFromImage(image());
+		}
+		return p;
+	}
+	
+	return pix;
+}
+
+bool KCrossBGRender::needWallpaperChange(){
+	if (!useCrossEfect) {
+		return KBackgroundRenderer::needWallpaperChange();
+	}
+
+	bool forceChange = setCurrentEvent();    // If we change the current state
+	if (forceChange){			 // do not matter what hapens
+		actualPhase = 0;                 // we need to change background
+		return true;
+	}
+
+	// Return false if it's not a transition
+	if (!current.transition) {
+		return false;
+	}
+
+	double timeLeft, timeTotal;
+	TQTime now = TQTime::currentTime();
+
+	timeLeft = now.secsTo(current.etime);
+	if (timeLeft < 0) {
+		timeLeft += 86400; // before midnight
+	}
+	timeTotal = current.stime.secsTo(current.etime);
+	if (timeTotal < 0) {
+		timeTotal += 86400;
+	}
+
+	double passed  = timeTotal - timeLeft;
+	double timeCell   =  timeTotal/60; //Time cell size
+
+	//kdDebug() << "\ntimeleft:" << timeLeft << " timeTotal:" << timeTotal 
+	//          << "\npassed:" << passed << " timeCell:" << timeCell
+	//	  << "\nactualPhase: " << actualPhase << endl;	
+
+	int aux = passed/timeCell;	
+	if(actualPhase != aux){
+		//kdDebug() << "needWallpaperChange() => returned true" << endl;
+		actualPhase = passed/timeCell;
+		return true;
+	}
+
+	//kdDebug() << "needWallpaperChange() => returned false" << endl;
+	return false;
+}
+
+/* 
+ * This method change the enabledEffect flag to TRUE of FALSE, according 
+ * with multiWallpaperMode and FileName (it needs to be a XML)
+ */
+void KCrossBGRender::fixEnabled(){
+
+	
+	TQString w = wallpaperList()[0];
+	useCrossEfect = false;	
+	if(multiWallpaperMode() == Random || multiWallpaperMode() == InOrder){
+		
+		if ( w != xmlFileName ){
+			// New XML File
+			xmlFileName = w;
+			if (w.endsWith("xml",false)){
+				initCrossFade(wallpaperList()[0]);
+				//useCrossEfect = true;	
+			}else{
+				// Not, it's not a xml file
+				useCrossEfect = false;
+			}
+		}else if (w.endsWith("xml",false)){
+			//xmlFile doesn't change
+			//but it's there
+			useCrossEfect = true;
+		}else{
+			// it's not a XML file
+			useCrossEfect = false;
+		}
+	}
+}
+
+void KCrossBGRender::changeWallpaper(bool init){
+
+
+
+	fixEnabled();
+
+	if (!useCrossEfect){
+		KBackgroundRenderer::changeWallpaper(init);
+		return;
+	}
+
+	pix = getCurrentPixmap();
+
+
+}
+
+
+bool KCrossBGRender::setCurrentEvent(bool init){
+	TQTime now = TQTime::currentTime();
+	
+
+	//Verify if is need to change
+	if (!(init || now <= current.stime || now >= current.etime )) {
+		return false;
+	}
+
+	TQValueList<KBGCrossEvent>::iterator it;
+	for ( it = timeList.begin(); it != timeList.end(); ++it ){
+
+		// Look for time
+		if ( ((*it).stime <= now && now <= (*it).etime) ||   //normal situation
+		     ((*it).etime <= (*it).stime && (now >= (*it).stime ||
+		     				     now <= (*it).etime) ) )	
+		{
+			current = *it;
+			actualPhase = 0;
+
+			//kdDebug() << "Cur: " << current.stime << "< now <" << current.etime << endl;
+			return true;
+		}
+	}
+}
+
+TQPixmap KCrossBGRender::getCurrentPixmap()
+{
+	float alpha;
+	TQPixmap ret;
+	TQImage tmp;
+	TQImage p1;
+	if (!tmp.load(current.pix1))
+		return TQPixmap();
+
+	// scale the pixmap to fit in the screen
+	//p1 = TQPixmap(QApplication::desktop()->screenGeometry().size());
+	//TQPainter p(&p1);
+	//p.drawPixmap(p1.rect(), tmp);
+	//
+	p1 = tmp.smoothScale(TQApplication::desktop()->screenGeometry().size());
+
+	if (current.transition){
+		TQTime now = TQTime::currentTime();
+		double timeLeft,timeTotal;
+
+		TQImage p2;
+
+		if (!tmp.load(current.pix2) )
+			return NULL;
+
+		p2 = tmp.smoothScale(TQApplication::desktop()->screenGeometry().size());
+		//TQPainter p(&p2);
+		//p.drawPixmap(p2.rect(), tmp);
+
+		timeLeft = now.secsTo(current.etime);
+		if (timeLeft < 0)
+			timeLeft += 86400;
+		timeTotal = current.stime.secsTo(current.etime);
+		if (timeTotal < 0)
+			timeTotal += 86400;
+		
+		alpha = (timeTotal - timeLeft)/timeTotal;
+
+		//ret = crossFade(p2,p1,alpha);
+		tmp = KImageEffect::blend(p2,p1,alpha);
+		ret.convertFromImage(tmp);
+		return ret;
+	}else{
+		ret.convertFromImage(p1);
+		return ret;
+	}	
+	
+
+}
+
+void KCrossBGRender::createStartTime(TQDomElement docElem)
+{	
+	int hour;
+	int minutes;
+
+	TQDomNode n = docElem.firstChild();
+	while( !n.isNull() ) {
+		TQDomElement e = n.toElement();
+		if( !e.isNull() ) {
+			if (e.tagName() == "hour"){
+				hour =  e.text().toInt();
+			}else if ( e.tagName() == "minute" ){
+				minutes = e.text().toInt();
+			}
+			
+		}
+		
+		n = n.nextSibling();
+	}
+	secs = hour*60*60 + minutes*60;
+}
+void KCrossBGRender::createTransition(TQDomElement docElem)
+{
+	int duration;
+	TQString from;
+	TQString to;
+
+	TQDomNode n = docElem.firstChild();
+	while( !n.isNull() ) {
+		TQDomElement e = n.toElement();
+		if( !e.isNull() ) {
+			if (e.tagName() == "duration"){
+				duration = e.text().toFloat();
+			}else if ( e.tagName() == "from" ){
+				from = e.text();
+			}
+			else if ( e.tagName() == "to" ){
+				to = e.text();
+			}
+			
+		}
+		n = n.nextSibling();
+	}
+	TQTime startTime(0,0,0);
+	startTime = startTime.addSecs(secs);
+	TQTime endTime(0,0,0);
+	endTime = endTime.addSecs(secs+duration);
+
+	secs += duration;
+	
+	KBGCrossEvent l = {true, from, to, startTime,endTime};
+
+	timeList.append(l);
+
+}
+void KCrossBGRender::createStatic(TQDomElement docElem)
+{	
+	int duration;
+	TQString file;
+	
+	TQDomNode n = docElem.firstChild();
+	while( !n.isNull() ) {
+		TQDomElement e = n.toElement();
+		if( !e.isNull() ) {
+			if (e.tagName() == "duration"){
+				duration = e.text().toFloat();
+			}else if ( e.tagName() == "file" ){
+				file = e.text();
+			}
+			
+		}
+		n = n.nextSibling();
+	}
+	
+	TQTime startTime(0,0,0);
+	startTime = startTime.addSecs(secs);
+	TQTime endTime(0,0,0);
+	endTime = endTime.addSecs(secs+duration);
+	
+	secs += duration;
+
+	KBGCrossEvent l = {false, file, NULL, startTime,endTime};
+	timeList.append(l);
+}
+
+#include "KCrossBGRender.moc"
--- ./tdm/kfrontend/krootimage.h.ORI	2013-05-08 18:54:48.631599139 +0200
+++ ./tdm/kfrontend/krootimage.h	2013-05-08 18:55:02.365339708 +0200
@@ -27,6 +27,7 @@
 #include <tqtimer.h>
 
 #include <bgrender.h>
+#include <KCrossBGRender.h>
 
 
 class MyApplication : public TDEApplication
--- ./kdesktop/bgmanager.cc.ORI	2013-05-08 18:56:29.915684768 +0200
+++ ./kdesktop/bgmanager.cc	2013-05-08 19:12:04.451954803 +0200
@@ -16,10 +16,16 @@
 #include "bgsettings.h"
 #include "kdesktopapp.h"
 
+//FIXME
+#include "KCrossBGRender.h"
+#include "crossfade.h"
+
 #include <assert.h>
 
 #include <tqtimer.h>
 #include <tqscrollview.h>
+#include <tqpainter.h>
+#include <tqdesktopwidget.h>
 
 #include <kiconloader.h>
 #include <tdeconfig.h>
@@ -34,6 +40,8 @@
 #include <X11/X.h>
 #include <X11/Xlib.h>
 #include <X11/Xatom.h>
+#include <X11/extensions/Xrender.h>
+#include <unistd.h>
 
 #ifndef None
 #define None 0L
@@ -47,7 +55,8 @@
 
 #include "pixmapserver.h"
 
-template class TQPtrVector<KBackgroundRenderer>;
+//template class TQPtrVector<KBackgroundRenderer>;
+template class TQPtrVector<KCrossBGRender>;
 template class TQPtrVector<KBackgroundCacheEntry>;
 template class TQMemArray<int>;
 
@@ -108,6 +117,12 @@
     connect(m_pTimer, TQT_SIGNAL(timeout()), TQT_SLOT(slotTimeout()));
     m_pTimer->start( 60000 );
 
+    /*CrossFade's config*/
+    m_crossTimer = new TQTimer(this);
+    connect(m_crossTimer, TQT_SIGNAL(timeout()), TQT_SLOT(slotCrossFadeTimeout()));
+    /*Ends here*/
+
+
     connect(m_pKwinmodule, TQT_SIGNAL(currentDesktopChanged(int)),
 	    TQT_SLOT(slotChangeDesktop(int)));
     connect(m_pKwinmodule, TQT_SIGNAL(numberOfDesktopsChanged(int)),
@@ -577,6 +592,36 @@
 
 
 /*
+ * This slot is called when the Timeout is executed
+ */
+void KBackgroundManager::slotCrossFadeTimeout()
+{
+    KVirtualBGRenderer *r = m_Renderer[fadeDesk];
+    if (crossInit) {
+        mBenchmark.start();
+    }
+
+    if (mAlpha <= 0.0 || mBenchmark.elapsed() > 300 ) {
+        bool do_cleanup = true;
+        mAlpha = 1;
+        m_crossTimer->stop();
+        KPixmap pixm(mNextScreen);
+        setPixmap(&pixm, r->hash(), fadeDesk);
+        return;
+    }
+    // Reset Timer
+    mBenchmark.start();
+
+    TQPixmap dst = crossFade(*mOldScreen, mNextScreen, mAlpha, crossInit);
+    KPixmap pixm(dst);
+    setPixmap(&pixm, r->hash(), fadeDesk);
+
+    mAlpha -=0.03;
+    crossInit = false;
+}
+
+
+/*
  * This slot is called when a renderer is done.
  */
 void KBackgroundManager::slotImageDone(int desk)
@@ -592,6 +637,10 @@
     KPixmap *pm = new KPixmap();
     KVirtualBGRenderer *r = m_Renderer[desk];
     bool do_cleanup = true;
+    fadeDesk = desk; 
+    mAlpha = 1.0;
+    int width,height;
+
 
     *pm = r->pixmap();
     // If current: paint it
@@ -603,7 +652,41 @@
         //setPixmap(viewport_background, r->hash(), desk);
         //delete viewport_background;
         
-        setPixmap(pm, r->hash(), desk);
+        //START
+        if (m_Renderer[effectiveDesktop()]->renderer(0)->crossFadeBg() && !m_Renderer[effectiveDesktop()]->renderer(0)->usingCrossXml()){	
+            int mode = m_Renderer[effectiveDesktop()]->renderer(0)->wallpaperMode();
+            width = TQApplication::desktop()->screenGeometry().width(); //m_pDesktop->width();
+            height = TQApplication::desktop()->screenGeometry().height();// m_pDesktop->height();	
+
+            if (mode == KBackgroundSettings::NoWallpaper || mode == KBackgroundSettings::Tiled || mode  == KBackgroundSettings::CenterTiled ){
+                mNextScreen = TQPixmap(width,height);
+                TQPainter p (&mNextScreen);
+                p.drawTiledPixmap(0,0,width,height,*pm);        
+            } else {
+                mNextScreen = TQPixmap(*pm);
+            }
+
+            if (m_pDesktop){
+                mOldScreen = const_cast<TQPixmap *>( m_pDesktop->backgroundPixmap() );
+            }else{
+                mOldScreen = const_cast<TQPixmap *>(
+                TQApplication::desktop()->screen()->backgroundPixmap() );
+            }
+
+            //TODO Find a way to discover if CrossFade effect needs to run  
+            if (mOldScreen){
+                crossInit = true;
+                m_crossTimer->start(70);
+            } else{
+                setPixmap(pm, r->hash(), desk);
+            }
+        }else{
+            setPixmap(pm, r->hash(), desk);
+        }
+        //ENDS HERE  */
+	    
+        //setPixmap(pm, r->hash(), desk);
+
         if (!m_bBgInitDone)
         {
             m_bBgInitDone = true;
@@ -801,7 +884,8 @@
 TQString KBackgroundManager::currentWallpaper(int desk)
 {
     //TODO Is the behaviour of this function appropriate for multiple screens?
-    KBackgroundRenderer *r = m_Renderer[validateDesk(desk)]->renderer(0);
+    //KBackgroundRenderer *r = m_Renderer[validateDesk(desk)]->renderer(0);
+    KCrossBGRender *r = m_Renderer[validateDesk(desk)]->renderer(0);
 
     return r->currentWallpaper();
 }
@@ -818,7 +902,7 @@
 // DCOP exported
 void KBackgroundManager::setExport(int _export)
 {
-    kdDebug() << "KBackgroundManager enabling exports.\n";
+//    kdDebug() << "KBackgroundManager enabling exports.\n";
     applyExport(_export);
     slotChangeDesktop(0);
 }
@@ -843,7 +927,7 @@
     //TODO Is the behaviour of this function appropriate for multiple screens?
     for (unsigned i=0; i < m_Renderer[effectiveDesktop()]->numRenderers(); ++i)
     {
-        KBackgroundRenderer *r = m_Renderer[effectiveDesktop()]->renderer(i);
+        KCrossBGRender *r = m_Renderer[effectiveDesktop()]->renderer(i);
         r->stop();
         r->setWallpaperMode(mode);
         r->setMultiWallpaperMode(KBackgroundSettings::NoMulti);
@@ -856,7 +940,7 @@
 void KBackgroundManager::setWallpaper(TQString wallpaper)
 {
     //TODO Is the behaviour of this function appropriate for multiple screens?
-    KBackgroundRenderer *r = m_Renderer[effectiveDesktop()]->renderer(0);
+    KCrossBGRender *r = m_Renderer[effectiveDesktop()]->renderer(0);
     int mode = r->wallpaperMode();
     if (mode == KBackgroundSettings::NoWallpaper)
        mode = KBackgroundSettings::Tiled;
@@ -869,7 +953,7 @@
 TQStringList KBackgroundManager::wallpaperFiles(int desk)
 {
     //TODO Is the behaviour of this function appropriate for multiple screens?
-    KBackgroundRenderer *r = m_Renderer[validateDesk(desk)]->renderer(0);
+    KCrossBGRender *r = m_Renderer[validateDesk(desk)]->renderer(0);
 
     return r->wallpaperFiles();
 }
@@ -880,7 +964,7 @@
 TQStringList KBackgroundManager::wallpaperList(int desk)
 {
     //TODO Is the behaviour of this function appropriate for multiple screens?
-    KBackgroundRenderer *r = m_Renderer[validateDesk(desk)]->renderer(0);;
+    KCrossBGRender *r = m_Renderer[validateDesk(desk)]->renderer(0);;
 
     return r->wallpaperList();
 }
@@ -907,7 +991,7 @@
     //TODO Is the behaviour of this function appropriate for multiple screens?
     for (unsigned i=0; i < m_Renderer[sdesk]->numRenderers(); ++i)
     {
-        KBackgroundRenderer *r = m_Renderer[sdesk]->renderer(i);
+        KCrossBGRender *r = m_Renderer[sdesk]->renderer(i);
     
         setCommon(false);   // Force each desktop to have it's own wallpaper
     
@@ -974,7 +1058,7 @@
     //TODO Is the behaviour of this function appropriate for multiple screens?
     for (unsigned i=0; i < m_Renderer[effectiveDesktop()]->numRenderers(); ++i)
     {
-        KBackgroundRenderer *r = m_Renderer[effectiveDesktop()]->renderer(i);
+        KCrossBGRender *r = m_Renderer[effectiveDesktop()]->renderer(i);
         r->stop();
     
         if (isColorA)
--- ./kdesktop/bgmanager.h.ORI	2013-05-08 19:13:25.120426716 +0200
+++ ./kdesktop/bgmanager.h	2013-05-08 19:15:12.071398460 +0200
@@ -13,6 +13,7 @@
 #include <tqstring.h>
 #include <tqptrvector.h>
 
+#include <tqdatetime.h>
 #include <KBackgroundIface.h>
 
 #if defined(Q_WS_X11) && defined(HAVE_XRENDER) && TQT_VERSION >= 0x030300
@@ -89,6 +90,7 @@
     void desktopResized();
     void clearRoot();
     void saveImages();
+    void slotCrossFadeTimeout();
     void slotCmBackgroundChanged(bool);
 
 private:
@@ -131,6 +133,15 @@
     KPixmapServer *m_pPixmapServer;
     
     unsigned long m_xrootpmap;
+
+    /*CrossFade vars*/
+    TQTimer * m_crossTimer;
+    double mAlpha;
+    TQPixmap  mNextScreen;
+    TQPixmap  * mOldScreen;
+    int fadeDesk;
+    TQTime mBenchmark;
+    bool crossInit;
 };
 
 #endif // __BGManager_h_Included__
--- trinity-tdebase-3.5.13.2~pre102+43d29f86/kcontrol/background/bgdialog_ui.ui.ORI	2013-05-15 12:13:14.000000000 +0000
+++ trinity-tdebase-3.5.13.2~pre102+43d29f86/kcontrol/background/bgdialog_ui.ui	2013-05-15 12:20:25.000000000 +0000
@@ -376,6 +376,17 @@
 &lt;/ul&gt;&lt;/qt&gt;</string>
                     </property>
                 </widget>
+                <widget class="TQCheckBox" row="8" column="1">
+                    <property name="name">
+                        <cstring>m_cbCrossFadeBg</cstring>
+                    </property>
+                    <property name="text">
+                        <string>Cross-fading background</string>
+                    </property>
+                    <property name="whatsThis" stdset="0">
+                        <string>Enables a smooth fading effect when changing background image.</string>
+                    </property>
+                </widget>
                 <widget class="TQComboBox" row="5" column="1">
                     <property name="name">
                         <cstring>m_comboBlend</cstring>
--- trinity-tdebase-3.5.13.2~pre102+43d29f86/kcontrol/background/bgdefaults.h.ORI	2013-05-15 13:42:20.933760867 +0000
+++ trinity-tdebase-3.5.13.2~pre102+43d29f86/kcontrol/background/bgdefaults.h	2013-05-15 13:42:38.305365721 +0000
@@ -34,5 +34,6 @@
 #define _defBlendMode KBackgroundSettings::NoBlending
 #define _defBlendBalance 100
 #define _defReverseBlending false
+#define _defCrossFadeBg false
 
 #endif // __BGDefaults_h_Included__
--- trinity-tdebase-3.5.13.2~pre102+43d29f86/kcontrol/background/bgsettings.h.ORI	2013-05-15 13:37:34.228282617 +0000
+++ trinity-tdebase-3.5.13.2~pre102+43d29f86/kcontrol/background/bgsettings.h	2013-05-15 13:39:31.884606381 +0000
@@ -198,6 +198,9 @@
     void setReverseBlending(bool value);
     bool reverseBlending() const { return m_ReverseBlending; }
 
+    void setCrossFadeBg(bool value);
+    bool crossFadeBg() const { return m_CrossFadeBg; }
+
     void setBlendBalance(int value);
     int blendBalance() const { return m_BlendBalance; }
 
@@ -273,6 +276,7 @@
     int m_BlendMode, defBlendMode;
     int m_BlendBalance, defBlendBalance;
     bool m_ReverseBlending, defReverseBlending;
+    bool m_CrossFadeBg, defCrossFadeBg;
     int m_MinOptimizationDepth;
     bool m_bShm;
     bool m_bDrawBackgroundPerScreen;
--- trinity-tdebase-3.5.13.2~pre102+43d29f86/kcontrol/background/bgsettings.cpp.ORI	2013-05-15 13:39:59.408980208 +0000
+++ trinity-tdebase-3.5.13.2~pre102+43d29f86/kcontrol/background/bgsettings.cpp	2013-05-15 13:46:15.197432823 +0000
@@ -437,6 +437,7 @@
     defBlendMode = _defBlendMode;
     defBlendBalance = _defBlendBalance;
     defReverseBlending = _defReverseBlending;
+    defCrossFadeBg = _defCrossFadeBg;
 
     m_MinOptimizationDepth = _defMinOptimizationDepth;
     m_bShm = _defShm;
@@ -537,6 +538,7 @@
     m_BlendMode = settings->m_BlendMode;
     m_BlendBalance = settings->m_BlendBalance;
     m_ReverseBlending = settings->m_ReverseBlending;
+    m_CrossFadeBg = settings->m_CrossFadeBg;
     m_MinOptimizationDepth = settings->m_MinOptimizationDepth;
     m_bShm = settings->m_bShm;
     m_MultiMode = settings->m_MultiMode;
@@ -633,6 +635,15 @@
 }
 
 
+void KBackgroundSettings::setCrossFadeBg(bool value)
+{
+    if (m_CrossFadeBg == value)
+	return;
+    dirty = hashdirty = true;
+    m_CrossFadeBg = value;
+}
+
+
 void KBackgroundSettings::setWallpaper(TQString wallpaper)
 {
     dirty = hashdirty = true;
@@ -774,6 +785,8 @@
 
     m_ReverseBlending = m_pConfig->readBoolEntry( "ReverseBlending", defReverseBlending);
 
+    m_CrossFadeBg = m_pConfig->readBoolEntry( "CrossFadeBg", defCrossFadeBg);
+
     // Multiple wallpaper config
     m_WallpaperList = m_pConfig->readPathListEntry("WallpaperList");
 
@@ -834,6 +847,7 @@
     m_pConfig->writeEntry("BlendMode", m_BlMRevMap[m_BlendMode]);
     m_pConfig->writeEntry("BlendBalance", m_BlendBalance);
     m_pConfig->writeEntry("ReverseBlending", m_ReverseBlending);
+    m_pConfig->writeEntry("CrossFadeBg", m_CrossFadeBg);
     m_pConfig->writeEntry("MinOptimizationDepth", m_MinOptimizationDepth);
     m_pConfig->writeEntry("UseSHM", m_bShm);
 
--- trinity-tdebase-3.5.13.2~pre102+43d29f86/kcontrol/background/bgdialog.h.ORI	2013-05-15 13:56:09.397921090 +0000
+++ trinity-tdebase-3.5.13.2~pre102+43d29f86/kcontrol/background/bgdialog.h	2013-05-15 13:56:17.377739605 +0000
@@ -80,6 +80,7 @@
    void slotBlendReverse(bool b);
    void desktopResized();
    void setBlendingEnabled(bool);
+   void slotCrossFadeBg(bool);
 
 protected:
    void getEScreen();
--- trinity-tdebase-3.5.13.2~pre102+43d29f86/kcontrol/background/bgdialog.cpp.ORI	2013-05-15 13:53:49.809095324 +0000
+++ trinity-tdebase-3.5.13.2~pre102+43d29f86/kcontrol/background/bgdialog.cpp	2013-05-15 13:53:54.636985486 +0000
@@ -174,6 +174,10 @@
    connect(m_cbBlendReverse, TQT_SIGNAL(toggled(bool)),
            TQT_SLOT(slotBlendReverse(bool)));
 
+   // Crossfading background
+   connect(m_cbCrossFadeBg, TQT_SIGNAL(toggled(bool)),
+           TQT_SLOT(slotCrossFadeBg(bool)));
+
    // advanced options
    connect(m_buttonAdvanced, TQT_SIGNAL(clicked()),
            TQT_SLOT(slotAdvanced()));
@@ -304,6 +308,7 @@
     m_cbBlendReverse->setEnabled( false );
     m_buttonAdvanced->setEnabled( false );
     m_buttonGetNew->setEnabled( false );
+    m_cbCrossFadeBg->setEnabled( false );
 }
 
 void BGDialog::load( bool useDefaults )
@@ -781,6 +786,8 @@
     m_cbBlendReverse->setChecked(r->reverseBlending());
     m_sliderBlend->setValue( r->blendBalance() / 10 );
 
+    m_cbCrossFadeBg->setChecked(r->crossFadeBg());
+
     m_comboBlend->blockSignals(false);
     m_sliderBlend->blockSignals(false);
 
@@ -1295,6 +1302,17 @@
    eRenderer()->start(true);
 }
 
+void BGDialog::slotCrossFadeBg(bool b)
+{
+   if (b == eRenderer()->crossFadeBg())
+      return;
+   emit changed(true);
+
+   eRenderer()->stop();
+   eRenderer()->setCrossFadeBg(b);
+   eRenderer()->start(true);
+}
+
 void BGDialog::desktopResized()
 {
    for (unsigned i = 0; i < m_renderer.size(); ++i)
